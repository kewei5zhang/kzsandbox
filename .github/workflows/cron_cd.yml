name: "cron_cd"

on:
  push:
    branches:
      - master
  workflow_dispatch:

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      job_id: ${{ steps.fetch_job_id.outputs.job_id }}
      image_tag: ${{ steps.extract_image_tag.outputs.image_tag }}
      release_needed: ${{ steps.check_release.outputs.release_needed }}
    steps:
      # Step 0: Checkout
      - name: Check Out The Repository
        uses: actions/checkout@v4.1.1
        with:
          fetch-depth: 0
          token: ${{ secrets.ACTION_READ_TOKEN }}

      # Step 1: Fetch latest waiting deploys_all job ID
      - name: Fetch latest waiting deploys_all job ID
        id: fetch_job_id
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          job_id=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/actions/workflows/deploy_all.yml/runs | jq '[.workflow_runs[] | select(.status == "waiting")][0].id')
          echo $job_id
          echo "job_id=${job_id}" >> $GITHUB_OUTPUT

      # Step 2: Download Artifact
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
          run-id: ${{ steps.fetch_job_id.outputs.job_id }}
          github-token: ${{ secrets.ACTION_READ_TOKEN }}
          path: ./artifacts

      # Step 3: Extract image tag
      - name: Extract image tag
        id: extract_image_tag
        run: |
          image_tag=$(cat ./artifacts/image_tag/image_tag.txt)
          echo "image_tag=${image_tag}" >> $GITHUB_OUTPUT

      # Step 4: Check if new release is needed
      - name: Check if new release is needed
        id: check_release
        run: |
          # current_short_sha=$(curl -s -H "x-bypass-bot-key: ${{ secrets.CF_X_BYPASS_BOT_KEY }}" https://api-mainnet.magiceden.io/health | jq -r '.version')
          # current_full_sha=$(git rev-parse "$current_short_sha")
          current_full_sha="977b2d4fb71826dc514418961701ec335fd0bf87"
          echo "current_full_sha=${current_full_sha}"
          echo "image_tag=${{ steps.extract_image_tag.outputs.image_tag }}"
          if [[ $current_full_sha == ${{ steps.extract_image_tag.outputs.image_tag }} ]]; then
            echo "RELEASE_NEEDED=false" >> $GITHUB_OUTPUT
            echo "No new release needed" >> "$GITHUB_STEP_SUMMARY"
          elif git merge-base --is-ancestor $current_full_sha ${{ steps.extract_image_tag.outputs.image_tag }}; then
            echo "RELEASE_NEEDED=true" >> $GITHUB_OUTPUT
            echo "New release needed" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "RELEASE_NEEDED=false" >> $GITHUB_OUTPUT
            echo "No new release needed" >> "$GITHUB_STEP_SUMMARY"
          fi
      
      # # Step 5: Check if prisma schema has changed
      # - name: Check if prisma schema has changed
      #   id: check_prisma_schema
      #   run: |
      #     # current_short_sha=$(curl -s -H "x-bypass-bot-key: ${{ secrets.CF_X_BYPASS_BOT_KEY }}" https://api-mainnet.magiceden.io/health | jq -r '.version')
      #     # current_full_sha=$(git rev-parse "$current_short_sha")
      #     current_full_sha="977b2d4fb71826dc514418961701ec335fd0bf87"
      #     echo "current_full_sha=${current_full_sha}"
      #     echo "image_tag=${{ steps.extract_image_tag.outputs.image_tag }}"
      #     if [[ $current_full_sha == ${{ steps.extract_image_tag.outputs.image_tag }} ]]; then
      #       echo "RELEASE_NEEDED=false" >> $GITHUB_OUTPUT
      #       echo "No new release needed" >> "$GITHUB_STEP_SUMMARY"
      #     elif git merge-base --is-ancestor $current_full_sha ${{ steps.extract_image_tag.outputs.image_tag }}; then
      #       echo "RELEASE_NEEDED=true" >> $GITHUB_OUTPUT
      #       echo "New release needed" >> "$GITHUB_STEP_SUMMARY"
      #     else
      #       echo "RELEASE_NEEDED=false" >> $GITHUB_OUTPUT
      #       echo "No new release needed" >> "$GITHUB_STEP_SUMMARY"
      #     fi

  release:
    needs: prepare
    runs-on: ubuntu-latest
    if: ${{ needs.prepare.outputs.release_needed == 'true' }}
    steps:
      # Step 0: Checkout
      - name: Check Out The Repository
        uses: actions/checkout@v4.1.1
        with:
          fetch-depth: 0
          token: ${{ secrets.ACTION_READ_TOKEN }}

      # Step 5: Generate release note
      - name: Release note
        id: release-note
        shell: bash
        run: |
          latest_tag="$(git ls-remote --tags origin 'release-v*' | awk -F"/" '{gsub(/\^\{\}/, "", $3); print $3}' | sort -r | head -n 1)"
          commit_to_release="${{ needs.prepare.outputs.image_tag }}"
          release_note="$(git --no-pager log --pretty=oneline --format='%h|%an|%s' $commit_to_release...$latest_tag| column -s\| -t)"
          release_tag="release-v0.1.$(date -u +'%Y%m%d%H%M')"
          echo "### Release Info" >> "$GITHUB_STEP_SUMMARY"
          echo "- **Image tag:** $commit_to_release" >> "$GITHUB_STEP_SUMMARY"
          echo "- **Release tag:** $release_tag" >> "$GITHUB_STEP_SUMMARY"
          echo "- **Release notes:**" >> "$GITHUB_STEP_SUMMARY"
          echo "$release_note" >> "$GITHUB_STEP_SUMMARY"
          echo "RELEASE_TAG=$release_tag" >> $GITHUB_ENV
          echo "RELEASE_NOTE<<EOF" >> $GITHUB_ENV
          echo "$release_note" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      # Step 6: Send Slack Notification - Release Notes
      - name: Send Slack notification - Deploying in 5 mins
        id: slack-deploying
        uses: slackapi/slack-github-action@v1.24.0
        with:
          channel-id: "C04KK1ZPQEN" #test-slack-integration
          payload: |
            {
              "text": "üï• Deploying ${{ needs.prepare.outputs.image_tag }} in 5 mins",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "üï• Deploying ${{ needs.prepare.outputs.image_tag }} in 5 mins"
                  }
                }
              ]
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          # SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
          # SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

      # Step 6: Send Slack Notification - Release Notes
      - name: Send Slack notification - Release Notes
        uses: slackapi/slack-github-action@v1.24.0
        with:
          channel-id: "C04KK1ZPQEN" #test-slack-integration
          payload: |
            {
              "text": "*Release Tag:*\n${{ env.RELEASE_TAG }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Release Tag:*\n${{ env.RELEASE_TAG }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": ${{ toJson(env.RELEASE_NOTE) }}
                  }
                }
              ]
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          # SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
          # SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

      # Step 7: Wait for 5 minutes for manual cancel
      - name: Wait for 5 minutes
        id: wait-for-cancel
        run: sleep 3

      # Step 8: Release Tagging
      - name: Release Tagging
        run: |
          git config --global user.name "GitHub Action"
          git config --global user.email "deployer@magiceden.io"
          git tag -a ${{ env.RELEASE_TAG }} ${{ needs.prepare.outputs.image_tag }} -m "New release tag ${{ env.RELEASE_TAG }}"
          git push origin ${{ env.RELEASE_TAG }}
        env:
          GITHUB_TOKEN: ${{ github.token }}

      - name: Send Slack notification
        uses: slackapi/slack-github-action@v1.24.0
        with:
          channel-id: "C04KK1ZPQEN" #test-slack-integration
          update-ts: ${{ steps.slack-deploying.outputs.ts }}
          payload: |
            {
              "text": "üöÄ Deploying ${{ needs.prepare.outputs.image_tag }} now",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "üöÄ Deploying ${{ needs.prepare.outputs.image_tag }} now"
                  },
                  "accessory": {
                    "type": "button",
                    "text": {
                      "type": "plain_text",
                      "text": "Deploys all job link"
                    },
                    "url": "https://github.com/${{ github.repository }}/actions/runs/${{ needs.prepare.outputs.job_id }}"
                  }
                }
              ]
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          # SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
          # SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

      # Step 10: Approve deployment
      - name: Approve deployment
        shell: bash
        run: |
          JSON_DATA=$(jq -n \
                        --arg eid "${{ env.ENVIRONMENT_ID }}" \
                        '{environment_ids: [$eid|tonumber], state: "approved", comment: "Auto-approval by GitHub Action"}')
          gh api \
            -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/actions/runs/${{ needs.prepare.outputs.job_id }}/pending_deployments \
            --input <(echo $JSON_DATA)
        env:
          GH_TOKEN: ${{ secrets.ACTION_READ_TOKEN }}
          ENVIRONMENT_ID: "591606016"

      # Step 11: Wait for deploys_all job to finish
      - name: Wait for deploys_all job to finish
        uses: ./.github/actions/wait_workflow_runs
        id: wait-for-workflow-action
        timeout-minutes: 60
        with:
          github-token: ${{ github.token }}
          run: ${{ needs.prepare.outputs.job_id }}

      # Step 12: Check if deploys_all job is successful
      - name: Check if deploys_all job is successful
        id: check-deploys-all-job
        run: |
          job_conclusion=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/actions/runs/${{ needs.prepare.outputs.job_id }} | jq '.conclusion')
          echo "JOB_CONCLUSION=${job_conclusion}" >> $GITHUB_ENV
          echo "JOB_CONCLUSION=${job_conclusion}" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ github.token }}

      - name: print JOB_CONCLUSION
        run: |
          echo ${{ env.JOB_CONCLUSION }}

      - name: Send Slack notification - Success
        id: slack-success
        if: ${{ env.JOB_CONCLUSION == 'success' }}
        uses: slackapi/slack-github-action@v1.24.0
        with:
          channel-id: "C04KK1ZPQEN" #test-slack-integration
          update-ts: ${{ steps.slack-deploying.outputs.ts }}
          payload: |
            {
              "text": "üéâ Deployment Success",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "üéâ Deployment Success"
                  },
                  "accessory": {
                    "type": "button",
                    "text": {
                      "type": "plain_text",
                      "text": "Deploys all job link"
                    },
                    "url": "https://github.com/${{ github.repository }}/actions/runs/${{ needs.prepare.outputs.job_id }}"
                  }
                }
              ]
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          # JOB_CONCLUSION: ${{ env.JOB_CONCLUSION }}
          # SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
          # SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

      # - name: Send Slack notification - Failure
      #   if: env.JOB_CONCLUSION == 'failure'
      #   id: slack-failure
      #   uses: slackapi/slack-github-action@v1.24.0
      #   with:
      #     update-ts: ${{ steps.slack-deploying.outputs.ts }}
      #     payload: |
      #       {
      #         "text": "üö® Deployment Failed",
      #         "blocks": [
      #           {
      #             "type": "section",
      #             "text": {
      #               "type": "mrkdwn",
      #               "text": "üö® Deployment Failed"
      #             },
      #             "accessory": {
      #               "type": "button",
      #               "text": {
      #                 "type": "plain_text",
      #                 "text": "Deploys all job link"
      #               },
      #               "url": "https://github.com/${{ github.repository }}/actions/runs/${{ needs.prepare.outputs.job_id }}"
      #             }
      #           }
      #         ]
      #       }
      #   env:
      #     JOB_CONCLUSION: ${{ env.JOB_CONCLUSION }}
      #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
      #     SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

      # - name: Send Slack notification - Cancelled
      #   if: always() && cancelled()
      #   id: slack-cancelled
      #   uses: slackapi/slack-github-action@v1.24.0
      #   with:
      #     update-ts: ${{ steps.slack-deploying.outputs.ts }}
      #     payload: |
      #       {
      #         "text": "‚èπÔ∏è Deployment Cancelled",
      #         "blocks": [
      #           {
      #             "type": "section",
      #             "text": {
      #               "type": "mrkdwn",
      #               "text": "‚èπÔ∏è Deployment Cancelled"
      #             },
      #             "accessory": {
      #               "type": "button",
      #               "text": {
      #                 "type": "plain_text",
      #                 "text": "Deploys all job link"
      #               },
      #               "url": "https://github.com/${{ github.repository }}/actions/runs/${{ needs.prepare.outputs.job_id }}"
      #             }
      #           }
      #         ]
      #       }
      #   env:
      #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
      #     SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
